# Лекция #8

DML: вставка, обновление, удаление, выборка данных

## Цели занятия

* разбираться в уровнях изоляции транзакций;
* избегать взаимных блокировок;
* разбираться в различных видах блокировок;
* строить транзакции в PostgreSQL;

## ACID

ACID (Atomicity, Consistency, Isolation, Durability) - это набор свойств, обеспечивающих надежность и целостность
транзакций в базах данных. PostgreSQL, как реляционная система управления базами данных (RDBMS), также поддерживает
ACID.

Вот краткое описание каждого из компонентов ACID в контексте PostgreSQL:

* Atomicity (Атомарность): Транзакции в PostgreSQL являются атомарными, что означает, что они либо выполняются целиком,
  либо не выполняются вообще. Если в рамках транзакции происходит ошибка, то все изменения, внесенные в базу данных до
  этой ошибки, откатываются.

* Consistency (Согласованность): PostgreSQL поддерживает согласованность данных с использованием ограничений (
  constraints) и триггеров (triggers). Ограничения могут быть заданы на уровне таблицы для обеспечения целостности
  данных.

* Isolation (Изоляция): Уровень изоляции транзакций определяет, какие изменения, внесенные в одной транзакции, видны в
  других транзакциях. PostgreSQL поддерживает различные уровни изоляции, такие как Read Uncommitted, Read Committed,
  Repeatable Read и Serializable. Пользователи могут выбирать подходящий уровень изоляции в зависимости от требований
  своего приложения.

* Durability (Долговечность): После успешного завершения транзакции изменения в базе данных остаются постоянными и
  сохраняются даже в случае сбоя системы или выключения питания. PostgreSQL обеспечивает долговечность, записывая
  изменения в журнал транзакций (transaction log), который может быть использован для восстановления после сбоя.

Пример использования ACID в PostgreSQL:

`BEGIN; -- начало транзакции
UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;
-- если все операции успешны
COMMIT; -- фиксация изменений
-- если произошла ошибка
ROLLBACK; -- откат изменений`

В этом примере, если одна из операций обновления не выполнится успешно, то все изменения откатываются (ROLLBACK), и база
данных остается в консистентном состоянии.

## MVCC

MVCC, или Multi-Version Concurrency Control, представляет собой механизм управления параллельным доступом к данным в
базе данных. PostgreSQL активно использует MVCC для обеспечения высокой степени изоляции транзакций и поддержки
одновременных операций чтения и записи.

### Основные принципы MVCC в PostgreSQL

* Версионирование данных: Каждая транзакция создает свою собственную версию данных в момент своего начала. В результате,
  в базе данных может существовать несколько версий одного и того же объекта данных.
* Транзакции видят свою версию данных: Каждая транзакция видит данные, как если бы она была единственной выполняющейся
  транзакцией в системе. Это обеспечивает высокую степень изоляции.
* Очистка (Garbage Collection) устаревших версий: PostgreSQL периодически осуществляет процесс очистки, который удаляет
  устаревшие версии данных, которые больше не нужны для поддержки активных транзакций. Это обеспечивает эффективное
  использование пространства в базе данных.

### Пример сценария использования MVCC

* Транзакция T1 начинается: Создается версия данных, которую видит транзакция T1.
* Транзакция T2 начинается после T1: T2 видит состояние данных, как если бы T1 еще не началась.
* T1 вносит изменения: Обновляется версия данных для T1, но T2 продолжает видеть состояние данных до начала T1.
* Транзакция T1 завершается: Новая версия данных становится видимой для всех транзакций.
* Очистка старых версий: PostgreSQL выполняет очистку старых версий данных, которые уже не нужны для активных
  транзакций.

Этот механизм позволяет обеспечивать высокую степень параллелизма при одновременном обслуживании множества транзакций в
PostgreSQL, что делает его мощным и эффективным для многозадачных приложений.

## Аномалии в PostgreSQL

В контексте баз данных аномалии обычно относятся к нежелательным и непредсказуемым результатам транзакций из-за
неправильной организации или обработки данных. В PostgreSQL, как и в любой другой реляционной базе данных, могут
возникнуть различные аномалии в результате операций чтения и записи. Вот несколько типов аномалий, которые стоит
учитывать:

* Аномалия чтения (Read Anomaly): Возникает, когда одна транзакция видит изменения, внесенные другой транзакцией,
  которая еще не была зафиксирована. Это может привести к проблемам с консистентностью данных.
* Аномалия обновления (Update Anomaly): Происходит, когда несколько транзакций обновляют одни и те же данные, и
  изменения одной транзакции перезаписывают изменения другой. Это может привести к потере данных и нарушению
  целостности.
* Аномалия вставки (Insertion Anomaly): Связана с невозможностью вставить определенные данные без наличия других данных.
  Например, если для добавления записи в таблицу требуется наличие данных в другой таблице, и эти данные отсутствуют,
  это может привести к аномалии вставки.
* Аномалия удаления (Deletion Anomaly): Возникает, когда удаление определенных данных приводит к потере других данных,
  которые также были связаны с удаленными данными. Это может нарушить целостность и согласованность данных.
* Аномалия смешивания (Mixing Anomaly): Связана с несогласованным состоянием данных в результате параллельного
  выполнения транзакций. Разные транзакции видят разные версии данных в разное время, что может вызвать путаницу и
  ошибки.

Для предотвращения аномалий в PostgreSQL и других реляционных базах данных, важно правильно проектировать схему базы
данных, использовать транзакции и устанавливать правильные уровни изоляции. Также важно обратить внимание на
использование индексов и оптимизацию запросов для минимизации возможных аномалий при одновременном доступе к данным.

## Уровни изоляции в PostgreSQL

Уровни изоляции транзакций в PostgreSQL определяют степень видимости изменений, внесенных одной транзакцией, для других
параллельно выполняющихся транзакций. PostgreSQL поддерживает четыре стандартных уровня изоляции, определенных
стандартом SQL:

Read Uncommitted (Чтение неподтвержденных данных):

* Это самый низкий уровень изоляции. В этом режиме транзакции могут
  видеть изменения, внесенные другими транзакциями, даже если эти изменения еще не были подтверждены (зафиксированы).
  Это
  может привести к аномалиям чтения, поскольку данные могут находиться в промежуточном состоянии.

`SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;`

Read Committed (Чтение подтвержденных данных):

* Это более строгий уровень, гарантирующий, что транзакции видят только те
  изменения, которые были подтверждены (зафиксированы). Это предотвращает аномалии чтения, но может все еще допускать
  аномалии записи и потерю данных.

`SET TRANSACTION ISOLATION LEVEL READ COMMITTED;`

Repeatable Read (Повторяемое чтение):

* Этот уровень изоляции гарантирует, что транзакции будут видеть только те данные,
  которые были в момент их начала, и изменения, внесенные другими транзакциями после начала текущей транзакции, не будут
  видны. Это предотвращает аномалии чтения и записи, но может все еще допускать аномалии вставки и удаления.

`SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;`

Serializable (Сериализуемое выполнение):

* Это самый строгий уровень изоляции. Он гарантирует, что транзакции будут
  выполнены так, как если бы они выполнялись последовательно, без одновременного доступа. Это предотвращает все
  аномалии,
  но может привести к блокировкам и ухудшению производительности.

`SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;`

Вы можете установить уровень изоляции для текущей транзакции с помощью оператора SET TRANSACTION ISOLATION LEVEL, как
показано в приведенных выше примерах. Уровень изоляции также можно установить в настройках сеанса или включить в
определении транзакции. Выбор уровня изоляции зависит от требований конкретного приложения и баланса между уровнем
безопасности и производительностью.

## Уровни блокировок в PostgreSQL

В PostgreSQL уровни блокировок регулируют доступ к данным и предотвращают конфликты между параллельно выполняющимися
транзакциями. Управление блокировками важно для обеспечения целостности данных и предотвращения возможных проблем, таких
как гонки за ресурсами. PostgreSQL предлагает различные уровни блокировок, позволяя выбирать оптимальный баланс между
консистентностью и производительностью.

Вот несколько основных уровней блокировок в PostgreSQL:

1. ACCESS SHARE (Доступ на чтение): Этот уровень блокировки предотвращает изменение данных транзакцией, но позволяет
   другим транзакциям читать данные.

`SELECT * FROM my_table FOR SHARE;`

2. ROW SHARE (Блокировка строки для чтения): Похожа на ACCESS SHARE, но блокирует только определенные строки, а не всю
   таблицу.

`SELECT * FROM my_table WHERE condition FOR SHARE;`

3. ROW EXCLUSIVE (Блокировка строки для записи): Предотвращает изменение или чтение строки транзакцией, пока другая
   транзакция не освободит блокировку.

`SELECT * FROM my_table WHERE condition FOR UPDATE;`

4. SHARE UPDATE EXCLUSIVE (Блокировка обновления в общем доступе): Предотвращает обновление или удаление строки
   транзакцией, но позволяет другим транзакциям читать данные.

`SELECT * FROM my_table WHERE condition FOR UPDATE NOWAIT;`

5. SHARE (Общий доступ): Предотвращает изменение, обновление, или удаление строки транзакцией, но позволяет другим
   транзакциям читать данные.

`SELECT * FROM my_table WHERE condition FOR SHARE NOWAIT;`

6. EXCLUSIVE (Исключительная блокировка): Предотвращает изменение, обновление, или удаление строки транзакцией, а также
   чтение данных другими транзакциями.

`SELECT * FROM my_table WHERE condition FOR UPDATE NOWAIT;`

Это всего лишь несколько примеров уровней блокировок в PostgreSQL. Выбор конкретного уровня блокировок зависит от
требований вашего приложения и желаемого баланса между параллелизмом и целостностью данных. Управление блокировками —
это важный аспект проектирования баз данных, и его следует тщательно рассматривать для оптимизации производительности и
предотвращения блокировок.

## Управление транзакциями в PostgreSQL

Управление транзакциями в PostgreSQL включает в себя начало, завершение и контроль изменений, вносимых в базу данных в
рамках транзакции. Транзакции в PostgreSQL обеспечивают ACID-свойства (Atomicity, Consistency, Isolation, Durability),
что гарантирует надежность и целостность данных.

Вот основные операции и концепции управления транзакциями в PostgreSQL:

1. Начало транзакции:

`BEGIN;`

Эта команда начинает новую транзакцию. В рамках транзакции можно выполнять несколько SQL-операторов.

2. Фиксация транзакции (Commit):

`COMMIT;`

Команда COMMIT фиксирует транзакцию, сохраняя все внесенные в базу данных изменения. После фиксации, изменения
становятся постоянными.

3. Откат транзакции (Rollback):

`ROLLBACK;`

Команда ROLLBACK отменяет все изменения, внесенные в рамках текущей транзакции, и возвращает базу данных в состояние,
которое было до начала транзакции.

4. Сохранение точек сохранения (Savepoints):

`SAVEPOINT savepoint_name;`

Сохранение точек сохранения позволяет вам делать частичные откаты внутри транзакции без полного отката. Например:

`SAVEPOINT my_savepoint;`

-- Внесение изменений
ROLLBACK TO my_savepoint; -- Откат изменений до точки сохранения

5. Уровни изоляции транзакций:
   Как упоминалось ранее, PostgreSQL поддерживает различные уровни изоляции транзакций, такие как Read Uncommitted, Read
   Committed, Repeatable Read и Serializable. Уровень изоляции может быть установлен для текущей транзакции с помощью
   оператора SET TRANSACTION ISOLATION LEVEL.

`SET TRANSACTION ISOLATION LEVEL Serializable;`

6. Точка сохранения:

`SAVEPOINT savepoint_name;`

Эта команда создает точку сохранения внутри транзакции, что позволяет вам в дальнейшем откатываться к этой точке.

7. Управление транзакциями в коде программы:
   В приложениях, взаимодействующих с PostgreSQL, управление транзакциями часто выполняется через язык программирования,
   используемый в приложении. Например, в Python с использованием библиотеки psycopg2:

python

`import psycopg2`

`conn = psycopg2.connect(database="mydatabase", user="myuser", password="mypassword", host="myhost")
cursor = conn.cursor()`

`try:
cursor.execute("BEGIN;")`

-- Выполнение SQL-операций

`cursor.execute("COMMIT;")
except Exception as e:
cursor.execute("ROLLBACK;")
print("Error:", e)
finally:
cursor.close()
conn.close()`

Управление транзакциями в PostgreSQL важно для обеспечения надежности и целостности данных в многопользовательской
среде. Корректное использование транзакций помогает избежать аномалий и обеспечивает предсказуемость поведения базы
данных.