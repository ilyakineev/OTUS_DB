# Домашнее задание

Транзакции

## Цель:

* Научимся использовать индексы в MySQL

## Описание/Пошаговая инструкция выполнения домашнего задания:

* Пересматриваем индексы на своем проекте. По необходимости меняем. 
* Задача - сделать полнотекстовый индекс, который ищет по свойствам, названию товара и описанию. Если нет аналогичной задачи в проекте - имитируем. 
Итог: анализируем свой проект - добавляем или обновляем индексы
  в README пропишите какие индексы были изменены или добавлены
  explain и результаты выборки без индекса и с индексом. 
* Реализация полнотекстового индекса.

## Критерии оценки:

Выполнение ДЗ: 10 баллов
плюс 2 балла за красивое решение
минус 2 балла за рабочее решение, и недостатки указанные преподавателем не устранены

## Решение:

### [Docker-compose](../docker/mysql/docker-compose.yml)

### Индексы

1. Для таблицы item несколько индексов которые должны повысить производительность при различных сценариях поиска данных.

2. **Количество строк в таблице item:**
```sql
select count(*) from item; -- 20473
```

3. **Размер таблицы item;**
```sql
SELECT CONCAT(ROUND(SUM(data_length + index_length) / (1024 * 1024), 2), ' MB') AS table_size
FROM information_schema.tables 
WHERE table_schema = 'OTUS_DB_MYSQL' 
AND table_name = 'item'; -- 4.36 MB
```

4. **Запрос на поиск Метчика с католожным номером 00017101;**
```sql
explain select COUNT(*) from item i where i.name = 'Метчик' and i.catalogue_number = '00017101';
```

5. **Результат без индекса: 1 строк получено - 12ms, 2023-12-25 в 21:31:39**
```
id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows |filtered|Extra      |
--+-----------+-----+----------+----+-------------+---+-------+---+-----+--------+-----------+
 1|SIMPLE     |i    |          |ALL |             |   |       |   |20540|     1.0|Using where|
```

6. **Создаем индек по двум полям catalogue_number,name.**
```sql
CREATE INDEX idx_item_name ON item(catalogue_number,name);
```
Результат: 1 строк получено - 3ms, 2023-12-25 в 21:33:22
 ```
id|select_type|table|partitions|type|possible_keys|key          |key_len|ref        |rows|filtered|Extra      |
--+-----------+-----+----------+----+-------------+-------------+-------+-----------+----+--------+-----------+
 1|SIMPLE     |i    |          |ref |idx_item_name|idx_item_name|514    |const,const|1575|   100.0|Using index|
 ```

7. **Удалить индекс idx_item_name**
```sql 
ALTER TABLE item DROP INDEX idx_item_name;
```

### Полнотекстовый индекс
Полнотекстовый индекс - предоставляет возможность эффективного поиска по текстовым данным в больших объемах. Для создания полнотекстового индекса для таблиц выше, нужно выполнить ряд шагов:

1. **Включите полнотекстовый поиск для таблицы**:

   Создать полнотекстовый индекс для столбца `name` в таблице `item`:

   ```sql
   ALTER TABLE item ADD FULLTEXT INDEX idx_fulltext_name (name);
   ```

2. **Пример использования полнотекстового поиска**:

   ```sql
    SELECT * FROM item WHERE MATCH(name) AGAINST('фрезая');
   ```

3. **Поиск по нескольким словам:**

   Если мы хотите найти все элементы, у которых в названии присутствуют слова "резец" и "сверло", мы можете использовать следующий запрос:

   ```sql
   SELECT * FROM item WHERE MATCH(name) AGAINST('резец сверло' IN BOOLEAN MODE);
   ```

4. **Использование операторов для более сложного поиска:**

   Мы можете использовать операторы, такие как `+`, `-` и `*` для более гибкого поиска. Например, если мы хотите искать элементы, у которых в названии есть слово "резец" и, возможно, слово "ISCAR", но не слово "фреза", запрос будет выглядеть так:

   ```sql
   SELECT * FROM item WHERE MATCH(name) AGAINST('+резец +ISCAR -фреза' IN BOOLEAN MODE);
   ```

5. **Использование расширенного поиска с сортировкой результатов:**

   Полнотекстовый поиск также может быть комбинирован с другими функциями SQL, например, с сортировкой:

   ```sql
   SELECT * FROM item WHERE MATCH(name) AGAINST('резец') ORDER BY name ASC;
   ```